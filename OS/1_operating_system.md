<p align= "center">
    <image src = "http://image.kyobobook.co.kr/images/book/xlarge/660/x9788973007660.jpg">
</p>


# 목차
- [목차](#%EB%AA%A9%EC%B0%A8)
- [3장 컴퓨터 시스템의 동작 원리](#3%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
  - [CPU와 I/O 연산](#cpu%EC%99%80-io-%EC%97%B0%EC%82%B0)
  - [인터럽트 처리 루틴](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%B2%98%EB%A6%AC-%EB%A3%A8%ED%8B%B4)
  - [인터럽트 백터](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EB%B0%B1%ED%84%B0)
  - [스택](#%EC%8A%A4%ED%83%9D)
  - [인터럽트 핸들링](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81)
  - [PCB : 프로세스 제어 블록](#pcb--%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D)
  - [소프트웨어 입터럽트](#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%9E%85%ED%84%B0%EB%9F%BD%ED%8A%B8)
  - [입출력 구조](#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0)
    - [동기 입출력](#%EB%8F%99%EA%B8%B0-%EC%9E%85%EC%B6%9C%EB%A0%A5)
    - [비동기식 입출력](#%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5)
  - [DMA : Direct Memory Access](#dma--direct-memory-access)
- [4장 인터셉트의 원리](#4%EC%9E%A5-%EC%9D%B8%ED%84%B0%EC%85%89%ED%8A%B8%EC%9D%98-%EC%9B%90%EB%A6%AC)
  - [인터럽트](#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)
    - [하드웨어 인터럽트](#%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)
    - [소프트 인터럽트](#%EC%86%8C%ED%94%84%ED%8A%B8-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)
      - [예외](#%EC%98%88%EC%99%B8)
      - [시스템 콜](#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C)
  - [시스템 콜](#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C-1)
  - [프로세스 상태](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C)
- [5장 프로세스 관리](#5%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC)
  - [프로세스 개념](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%9C%EB%85%90)
  - [프로세스 상태](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-1)
  - [프로세스 제어 블록 PGB](#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4-%EB%B8%94%EB%A1%9D-pgb)
  - [문맥 교환](#%EB%AC%B8%EB%A7%A5-%EA%B5%90%ED%99%98)
- [6장 프로세스 관리](#6%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC)
  - [CPU 버스트](#cpu-%EB%B2%84%EC%8A%A4%ED%8A%B8)
  - [I/O 버스트](#io-%EB%B2%84%EC%8A%A4%ED%8A%B8)
  - [CPU 스케쥴러](#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC)
    - [비성점형 방식](#%EB%B9%84%EC%84%B1%EC%A0%90%ED%98%95-%EB%B0%A9%EC%8B%9D)
    - [선점형 방식](#%EC%84%A0%EC%A0%90%ED%98%95-%EB%B0%A9%EC%8B%9D)
  - [디스패치](#%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B9%98)
  - [스케쥴링의 성능 평가](#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80)
  - [스케쥴링 알고리즘](#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
    - [FCFS](#fcfs)
    - [SJF](#sjf)
- [7장 메모리 관리](#7%EC%9E%A5-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)
- [8장 가상 메모리](#8%EC%9E%A5-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)
- [9장 디스크 관리](#9%EC%9E%A5-%EB%94%94%EC%8A%A4%ED%81%AC-%EA%B4%80%EB%A6%AC)

# 3장 컴퓨터 시스템의 동작 원리

## CPU와 I/O 연산
입출력 장치들의 I/O 연산은 I/O 컨트롤러가 담당하고, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당하게 된다. 

디스크나 키보드 등에서 데이터를 읽어오는 경우, 우선 로컬 버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다.이 때, 장치에서 로컬 버퍼로 일어오는 일을 컨트롤러가 담당한다. 

데이터를 모두 가지고 왔는지 확인하는 작업은 메인 CPU가 일일이 체크하는 것이 아니라 장치에 있는 컨트롤러가 인터럽트를 발생시켜 CPU에게 보고하게 된다.

이 때 인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방식을 말한다.

CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 체크하게 된다. 인터럽트가 발생했으면 다음 명령을 수행하기 전에 인터럽트를 처리하게 되고 그 렇지 않으면 다음 명령을 계속 수행하게 되는 것이다.

인터럽트는 키보드 입력 혹은 디스크에서 데이터를 다 읽었다는 등의 이벤트를 CPU에게 알려줄 필요가 있는 경우 컨트롤러가 발생시킨다.

## 인터럽트 처리 루틴
* 운영체제는 각종 하드웨어, 소프트웨어 자원 관리뿐 아니라 사용자 프로그램에게 필요한 서비스도 제공한다. 
* 운영체제가 해야 할 일들을 운영 체제의 개발자가 미리 프로그래밍을 해서 커널 내에서 포함시켜 두게 된다. **그 중 한가지가 인터럽트 처리 루틴 이다.**
* 운영 체제 커널 내에 있는 인터럽트 처리 루틴은 다양한 인터럽트에 대해 각각 처리해야할 업무를 정의하고 있다.

## 인터럽트 백터
* 하드웨어 인터럽트이든, 소프트웨어 인터럽트이든 간에 일단 인터럽트가 발생하면 CPU는 하던 일을 멈추고 인터럽트를 처리하기 위한 루틴에 들어가서 정의된 일을 찾게 된다.
* 운영체제는 할 일을 쉽게 찾아가기 위해 인터럽트 백터를 가지고 있다.
* **운영체제 백터란 인터럽트의 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다.**

## 스택
* 실행중인 함수에서 다른 함수를 호출한 경우 호출된 함수의 종료 후 원래 함수의 실행중이던 위치로 돌아가기 위해 복귀 주소를 저장하는 영역이다.
* 호출된 함수를 모두 수행하고나면 원래 함수의 수행되던 위치로 돌아가게 되는데 이때 스택에 저장되어 있는 복귀 주소를 활용하게 된다. 

## 인터럽트 핸들링
* 인터럽트 핸들링 이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다. 


## PCB : 프로세스 제어 블록
* CPU에서 명령이 수행될 때 에는 CPU내 부에 있는 임시 기억장치인 레지스터에서 데이터를 읽어 오가나 쓰면서 작업을 수행함 이때 인터럽트가 발생하면 새로운 명령을 수행하면서 기존의 레지스터 값들이 지워지게 되므로 레지터 값 등 CPU 내의 하드웨어 상태를 저장해 두어야 한다. 
* **운영 체제 커널 영역에는 현재 시스템 내에서 수행되는 프로그램들 관리하기 위한 자료 구조인 프로세스 제어 블록에 두고 있다.**
  

## 소프트웨어 입터럽트
* 프로그램이 수행되거나 접근해서는 안 되는 메모리 여역을 침범하려는 경우, 0으로 나누는 연산을 시도하는 경우 등 예외 상황이나 시스템 콜 시에 발생하며 이 때 소프트웨어적으로 발생되는 인터럽트를 의미한다. 

## 입출력 구조
* 입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고 받는 것을 말한다. 

### 동기 입출력
* 입출력 요청후 입출력 작업이 완료된 후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다.
* 프로그램이 디스크에서 어떠한 정보를 읽어 오라는 요청을 했을 때 디스크 입출력이 완료 되기 전까지 시간이 걸리게 된다. 이때 동기식 입출력은 입출력이 진행되는 동안 프로그램이 다음 영령을 수행하지 않고 기다리게 된다. 그러다가 입출력이 완료되어 인터럽트를 통해 그 사실이 전달된 후에야 CPU의 제어권이 그 프로그램에게 넘어가거 다음 명령을 수행할 수 있게 된다.
* 따라서 동기식 입출력에는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할수 없다. CPU의 명령 수행 속도는 빠른 반면 외부 장치에서 데이터를 읽어 오는 등의 입출력 연산은 상대적으로 속도가 느리다. 그럼에도 불구하고 입출력이 완료될 때 까지 기다렸다가 사용자 프로그렘에게 CPU 제어권을 넘기는 방식은 입출력이 완료될 때까지 CPU가 아무 일도 하지 못하기 때문에 자원의 낭비를 초래하게 된다. 따라서 **일반적으로 프로그램이 입출력을 수행중인 경우 CPU를 다른 프로그램에게 이양해서 CPU가 계속 쉬지 않고 이을 할 수 있도록 관리한다.**
* 입출력이 완료 될 때까지 그 프로그램에게 CPU를 할당핟라도 명령을 수행하지 못하게 한다 이 것을 프로그램 봉쇄 상태(Block State)로 전환시킨다고 말한다.

### 비동기식 입출력
* 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식을 말한다.
* 어떤 프로그램이 데이터 디스크에서 읽어 오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서 그 데이터와 관련 없이 수행할 수 있는 일이 있을 수 있다. 비동기식 입출력에서는 그러한 작업을 먼저수행하고, 읽어오는 데이터가 반드시 있어야 할 수행할 수 있는 일들을 입출력이 완된후에 수행하게 된다.

* 비동기식 입출력에서는 CPU의 제어권을 입출력을 요청한 프로세스에게 곧바로 다시 주어지게 되며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 비동기식 칩출력에서도 입출력 연산이 완료되면 도기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려주게 된다. 그러면 그 시점 부터 읽어온 데이터를 필요하는 명령을 수행할 수있게 된다.


## DMA : Direct Memory Access
* 원칙적으로 메모리는 CPU에 의해서만 접근이 가능한 정차이다. 따라서 주변 장치들이 메모리에 접근하기 위해서는 CPU에게 인터럽트를 발생시켜 CPU가 일을 대행하는 식으로만 가능하다.

# 4장 인터셉트의 원리

## 인터럽트

### 하드웨어 인터럽트 
* 인터럽트는 일반적으로 하드웨어 인터럽트를 의미한다.
* **하드웨어 컨트롤러가 CPU의 서비스를 요청허가 위해 발생시키는 인터럽트가 일반적인 의미의 인터럽트를 지창하는 것이다.**
* CPU는 매번 프로그램이 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고서 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지를 체크한다. 인터럽트 라인 체크를 통해 인터럽트가 발생했으면는 현재 수행하던 프로세스를 멈추고 운영 체제의 인터럽트 처리 루틴으로 이동해서 인터럽트 처리를 수행한다.

### 소프트 인터럽트
* 트랩이란 소프트웨어가 발생시키는 인터럽트를 의미한다.

#### 예외
* 프로그램이 허용하지 않은 연산을 후행하려고 할 때 자동적으로 발생하는 것으로 운영 체제는 예외 상황이 발생했을때 CPU의 제어권을 획득해 해당 상횡에 대한 조치를 취하게 된다.
* 예외로는 0으로 나누는 연산, 자신의 주소 공간을 넘어서는 메모리 참조 등이 있다.


#### 시스템 콜
* 사용자 프로세스가 운영 체제의 서비스를 요청하기 위해 커널의 함수를 호출하는 것이다.
* 사용자 프로세스가 직접 특권 명령을 수행할 수 없음으로 사용자 프로세스가 특권 명령을 수행하려 할 때 시스템 콜을 사용하게된다.
* **시스템 콜이나 예외 상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영 체제에게 이양되어 처리되는데 이 과정에서 인터럽트 라인을 세팅하여 인터럽트를 발생 시킨 후 제어권이 넘어가게 되므로 이들을 넒은 의미에서는 이터럽트의 범주에 포함시킨다.**



## 시스템 콜
* 컴퓨터 시스템에서는 하드웨어 및 소프트웨어 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다.
* 이러한 관리를 하드웨어적으로 관리하기 위해 모드 비트를 두고 모두 비트가 0으로 셋팅된 경우에는 커널 모드라고 부르며, 모드 비트가 1로 세팅된 경우를 사용자 모드라고 부른다.
* CPU는 매 시점 명령을 수행하기 전에 현재 모드를 비트를 체크해 커널 모드인 경우에만 특권 명령을 수행 할 수 있도록 제한 하고 있다. 
* **사용자 프로그램이 CPU의 제어권을 가지고 프로그램을 수행하다보면, 입출력 등 특권 명령을 수행해야할 필요가 있다. 이 경우 사용자 프로그램은 운영 체제에게 시스템 콜을 통해 특권 명령의 대행을 요청하게 된다. 사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 운영 체제로 넘어가게된다. 이때 하드웨어적으로 모드 필트가 1에서 0으로 자동으로 셋팅되기 때문에 운영체제는 특권 명령을 수행할 수 있다.**


## 프로세스 상태

![](/assets/process-flow.png)

상태 | 설명
---|---
실행 | CPU를 할당 받고 기계어 명령을 수행하고 있는 프로세스의 상태를 가리킨다.
준비 | CPU만 할당받으면 당장 명령을수행 할 수 있지만 CPU가 하나밖에 없어 현재 CPU를 할당 받지 못한 프로세스의 상태
봉쇄(blocked, wait, sleep) | 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태를 말한다. 


# 5장 프로세스 관리

## 프로세스 개념
* 프로세스란 수행중인 프로그램을 뜻한다.
* 디스크에 실행 파일 형태로 존재하던 프로그램이 메모리에 올라가서 수행되기 시작하면 비로서 생명력을 갖는 프로세스가 되며 프로세스는 CPU를 획득해 자신의 코드를 수행 또는 CPU를 반호나하고 입출력 작업을 수행하기도 한다.


## 프로세스 상태
![](/assets/process-flow.png)

![](/assets/proccess-status.png)

1. 프로세스 준비 상태 : CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당 받지 못한 상태
2. 프로세스 시작 상태 : 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 승인받지 못한 생태
3. 프로세스 시작 상태 : CPU를 할당 받고 기계어 명령을 하나씩 수행해 나가는 상태
4. 디스크에서 파일을 읽어와야 하는 명령 수행
5. 디스크 입출력이 진행되는 동안에 이 프로세스가 CPU를 점유하고 있어도 후속 명령을 처리하지 못해서 CPU가 비효율적으로 낭비된다. 따라서 입출력이 완료될 때까지 CPU를 반환한 다음 디스크 입출력 서비스를 기다리는 장치에 큐에 가서 줄을 서게 된다. 이 때 프로세스의 상태는 봉쇄 상태가 된다. 그러면 CPU를 기다리는 준비 큐에 줄 서 있는 프로레스들 중에서 CPU 스케쥴러가 적절한 프로세스를 하나 선정해서 CPU를 할당하게 된다.
6. CPU를 기다리는 준비 큐에는 입출력 등 오래 기달려야 하는 업무가 진행 중인 프로세스는 줄 서 있지 못하고 CPU만 획득하면 곧바로 명령을 수행할 수 있는 프로레스들만 줄 서 있게 된다.  이러한 상태를 준비 상태라고 한다. 
7. 디스크 입출력을 요청한 프로세스는 디스크 입출력을 기다리는 장치 큐에 줄서 있다가 자기 차례가 되어 디스크 컨트롤로 부터 서비스를 받고 나면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시켜 입출력이 완료되었다는 것을 알리게 된다.
8. CPU는 어떤 프로세스를 실행하고 있다가 인터럽트가 발생한 것을 확인하고 그에 대응하는 루틴을 수행하게된다. 이 루틴이 진행되는 동안 CPU에서 수행되던 프로세스를 장치 큐에서 빼내어 CPU를 기다리는 준비 큐에 넣어 주고 프로세스의 상태를 준비 상태로 바꾼 후 장치의 로컬 버퍼에 있는 내용을 메로리에 디동시키는 일련의 업무이다.
9. 인터럽트 처리가 끝나면 인터럽트 처리 루틴 이전에 수행되던 프로세스에게 CPU를 다시 할당해 그 프로세스의 상태가 커널 모드에서 다시 사용자 모드 실행 상태로 변경되도록한다.

## 프로세스 제어 블록 PGB

프로세스 제어 블록이란 운영체제가 시스템 내의 프로세스를 관리하기 위해 프로세스당 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다. 구성 요소는 다음 과 같다.

* 프로세스 상태 : 프로세스의 상태는 CPU를 할당해도 되는 지 여부를 결정하기 위해 필요
* 프로그램 카운터 값 : 다음에 수행할 명령의 위치를 가리킴
* CPU 레지스터 : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄
* CPU 스케쥴링 정보 : 각각 그 프로세스의 CPU 스케쥴링을 위해 필요한 정보
* 메모리 관리 정보 : 각각 그 프로세스의 CPU 스케쥴링을 위해 필요한 정보
* 자원 사용 정보 : 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용 
* 입출력 상태 정보 


## 문맥 교환 
* 문맥 교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스 CPU의 제어권이 이양되는 과정을 뜻한다.
* 사용자 프로세스가 CPU를 할당 받고 실행되던 중에 타이머 인터럽트가 발생하면 CPU의 제어권은 운영체제에게 넘어가게 된다. 그러면 운영체제는 타이머 인터럽트 처리 루틴으로가서 직전까지 수행중이던 프로세스의 문맥을 저장하고 새롭게 실행시킬 프로세스에게 CPU를 이양한다 이 과정에서 원래 수행중이던 프로세스는 준비 상태로 바뀌고 새롭게 CPU를 할당받은 프로세스는 실행 상태가 된다.
* 프로세스가 실행 중인 상태 일 때 시스템 콜이나 인터럽트가 발생하면 CPU 제어권 운영 체제에게로 넘어와 원래 실행주이던 프로세스의 업무를잠시 멈추고 운영체제 커널 코드가 실행된다. 이 경우도 CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PGB에 저장하게 되지만 이러한 **이러한 과정을 문맥 교환이라고 하지 않는다,** 이는 하나의 프로세스가 사용자 모드에서 실행되다가 커널 모드로 실행 모드만 바뀌는 것일 뿐 CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이나니기 때문이다. **이와 같은 모드 변경에 비해 문맥 교환에는 훨씬 많은 오버헤드가 뛰다르게 된다.**

# 6장 프로세스 관리

## CPU 버스트
사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계

## I/O 버스트
* I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린단계
* I/O 버스트는 I/O 작업이 요청된 후 완료되어 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업을 말한다.

## CPU 스케쥴러
* CPU 스케쥴러는 준비 상태에 있는 프로세스들 중에 어떠한 프로세스에게 CPU를 할당할지를 결정하는 운영체제의 코드이다.
* 어떠한 프로세스가 CPU를 할당받고 기계어 명령을 수행하다가 타이머 인터럽트가 발생하면 CPU 스케쥴러가 호출된다. 그러면 CPU 스케쥴러는 준비 큐에서 CPU를 기다리는 프로세스 중에서 하나를 선택해 CPU를 할당하게된다.

### 비성점형 방식
* CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법을 말한다.
* 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우
* CPU에서 실행 상태에 있는 프로세스가 종료되는 경우


### 선점형 방식
* 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케쥴링 방법을 말한다.
* 실행 상테에 있던 프로레스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
* I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우

## 디스패치 
* CPU 스케쥴러가 어떤 프로세스에게 CPU를 할당해야 할지를 결정하고 나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요하다. **이와 같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경을 설정하는 모듈을 디스패처라고 부른다.**
* 디스패처는 현재 수행주이던 프로세스의 문맥을 그 프로세스의 PGB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PGB로부터 복원한 후 그 프로세스에게 넘기는 과정을 수행한다.
* 디스패처 지연시간 : 디스패처가 하나의 프로세스를 정지 시키고 다른 프로세스에게 CPU를 전달하기 까지 걸리는 시간

## 스케쥴링의 성능 평가
* CPU 활용도 : 전체 시간 중 CPU가 명령을 수행한 시간의 비율
* 처리량: 주어진 시간 동안 CPU 버스트를 완료한 프로세스의 개수
* 소요 시간 : 프로세스가 CPU 요청 시점으로 부터 CPU 버스트가 끝날 때까지 걸린 시간
* 대기 시간 : 프로세스가 CPU 버스트 기간 중 준비큐에서 기달린 시간의 합
* 응답 시간 : 프로세스가 CPU 요청 시점으로 처음으로 CPU를 얻을 때까지 기달린 시간

## 스케쥴링 알고리즘

### FCFS
* 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말한다.
* CPU를 먼저 요청한 프로세스에게 CPU를 먼저할당하고, 그 프로세스가 자발적으로 CPU를 반납할 때까지 CPU를 선점하지 않는다.
* 은행, 공항, 화장실 등 일상 생활에서도 흔히 볼수 있듯이 먼저 요청을 먼저 처리하기 때문에 합리적인 스케쥴링 방식인 것처럼 느껴지지만 I/O 오래 걸리는 작업이나, CPU 버스트가 짧은 프로세스 등 다양한 이유 때문에 평균 대기시간이 길어지게 된다.

### SJF
* CPU 버스트가 가장 짧은 프로세스 에게 제일 먼저 CPU를 할당하는 방식이다.
* CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하는 준비 큐를 빠져나가게 되며 프로세스들이 준비 큐에서 기다리는 전체적인 시간이 줄어들게 된다.
* SJF 스케쥴링 알고리즘은 평균 대기시간이 가장 짧게 하는 최적의 알고리즘으로 알려져있다.





# 7장 메모리 관리

# 8장 가상 메모리

# 9장 디스크 관리

