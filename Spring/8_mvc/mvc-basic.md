> 출처 [스프링5.0 마스터](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791161751825&orderClick=LAG&Kc=)을 보고 정리한 내용입니다.

# 스프링 MVC
스프링 MVC는 깔끔하고, 느슨하게 결합된 아키텍처라는 장점이있다. 스프링 MVC가 컨트롤러, 핸들러 매핑, 뷰 리졸버, POJO, Bean에 대한 역할을 명확하게 정의하면 의존성 주입 및 자동 와이어링과 같은 모든 핵심 스프링 기능을 사용해 웹 애플리케이션을 간단하게 만들 수 있다. 

## 자바 웹 애플리케이션 아키텍처

대표적인 웹 아키텍처는 다음과 같다.

* 모델 1 아키텍처
* 모델 2 아키텍처
* 프런트 컨트롤러가 있는 모델2


### 모델 1 아키텍처 
모델 1 아키텍처는 자바 기반 웹 애플리케이션을 개발하는 데 사용되는 초기 아키텍처 스타일중 하나다.

* JSP 페이지는 브라우저에서 요청을 직접 처리했다.
* JPS 페이지는 간단한 자바 빈을 포함하는 모델을 사용했다.
* 이 아키첵처 스타일의 일부 애플리케이션에서 JSP가 데이터베이스에 대한 쿼리를 수행했다

다음과 같은 단점들이 있다.
* 어려운 관심 분리 : JPS는 데이터 검색, 데이터 표시, 다음에 표시할 페이지 결정 때로는 비즈니스 로직까지도 담당했다.
* 복잡한 JPS: JPS가 많은 로직을 처리했기 때문에 거대하고 유지 보수하기 어렵다.

### 모델 2 아키텍처 
모델2 아키첵처는 모델 1의 여러 책임이있는 복잡성을 해결하기 위해 도입됐다.

* 모델 : 뷰를 생성하는 데 사용 할 데이터를 나타낸다.
* 뷰 : 모델을 사용해 화면을 랜더링한다.
* 컨트롤러 : 흐름을 제어한다. 브라우저에서 요청을 가져와 모델을 채우고 뷰로 라이렉션을한다.

### 모델 2 프론트 컨트롤러 아키첵처
모델 2 아키텍처의 기본 버전에서 브라우저 요청은 다른 서블릿(또는 컨트롤러)에 의해 직접 처리된다. 여러 비즈니스 시나리오에서 요청을 처리하기 전에 서블릿에 일반적인 몇가지 작업을 수행하려고한다. 예를 들면 로그인한 사용자가 요청을 실행할 수 있는 권한이 있는지 확인하는 것이다.

이것은 모든 서블릿에서 구현하길 원치 않은 공통 기능이다. 모델 2 프런트 컨트롤러 아키첵터에서는 모든 요청이 프론트 컨트롤러라는 단일 컨트롤러로 전달 된다. 

일반적인 프론트 컨트롤러의 책임은 다음과 같다.
* 어떤 컨트롤러가 요청을 실행할지 결정한다.
* 렌더링할 뷰를 결정한다.
* 좀 더 일반적인 기능을 추가하는 조항을 제공한다
* 스프링 MVC는 프런트 컨트롤러에서 MVC 패턴을 사용한다. 프론트 컨트롤러는 DispacherServlet이다. 


## 스프링 MVC 개요
중요 기능은 다음과 같다.
* 각 객체에 대한 잘 정의된 독립적인 역할을 가진 느슨하게 결합된 아키첵처다.
* 유연한 컨트롤러 메서드 정의다. 컨트로러 메서드는 다양한 범위의 파라미터와 반환값을 가질 수 있다. **이는 프로그래머가 자신에 필요에 맞는 정의를 선택할 수 있는 유연성을 제공한다.**
* **도메인 객체를 폼 백엔드 객체로 재사용할 수 있다.(가장 핵심)** 별도의 서식 객체를 가져야할 필요성이 줄어든다.
* 현지화를 지원하는 태그 라이브러리가 내장되있다.
* 유연한 바인딩이다. 바인딩하는동안 불일치되는 타입은 런타임 에러 대신 벨리데이션 에러로 해결 할 수 있다.

### 동작 흐름

![spring-mvc-flow](/assets/spring-mvc-flow.png)

1. 브라우저는 특정 URL에 요청을 보낸다. DispacherSevlet은 모든 요청을 처리하는 프론트 컨트롤러이다. 그래서 DispacherSevlet이 요청을 받는다.
2. DispacherSevlet URI를 보고, 이를 처리하기 위해 올바른 컨트롤러를 식별 해야한다. 올바른 컨트롤러를 찾는 데 도움을 주기위해 핸들러 매핑과 통신한다.
3. 핸들러 매핑은 요청을 처리하는 특정 핸들러 메서드(BasicModelViewController)를 반롼한다.
4. DispacherSevlet은 특정 핸들러 메서드를 호출한다.
5. 핸들러 메서드는 모델 뷰를 반환한다. ModleAndView 객채나 혹은 @ResponseBody 어노테이션이 있으면 모델 뷰를 반환하지 않는다.(modleAndView를 null로 반환하고 서블릿 내부 코드의 HttpMessageConverter에 의해서 직렬화 작업이 진행된다.)
6. DispacherSevlet에는 논리적 뷰 이름이 있다. 따라서 물리적 뷰 이름을 결정하는 방법을 알아내야한다. 사용할 수있는 뷰 리졸버가 있는지 여부를 확인하고 설정된 뷰 리졸버를 찾는다.
7. 뷰 리졸버는 논리적 뷰 이름을 물리적 뷰 이름에 매핑하는 로직을 실행한다.
8. DispacherSevlet은은 뷰를 실행한다. 또한 뷰에서 모델을 사용할 수 있게한다.
9. 뷰는 DispacherSevlet으로 보내질 내용을 반환한다.
10. DispacherSevlet은 응답을 다시 브리우저로 보낸다.



## MVC 주요 기능
* 각 객체에 대해 잘 정의된 독립적인 역할을 가진 느슨하게 결합된 아키텍처 이다.
* 컨트롤러 메서드는 다양한 범위의 파라미터와 반환값을 가질 수 있어 개발자가 자신의 필요에 맞는 정의를 유연하게 선택할 수 있다.
* 도메인 객체를 폼 백엔드 객체로 재사용할 수 있다.
* 모델은 `Key - Value`를 갖는 해시 맵을 사용한다. 여러 뷰 기술과의 통합을 허용한다.
* 유연하게 바인딩되어 런타임 에러 대신 벨리데이션 에러로 해결 할 수 있다.
* 단위 테스트 컨트롤러 Mock MVC 프레임워크가 포함돼 있다.


## 참고
* [스프링 5.0 마스터](http://acornpub.co.kr/book/mastering-spring-5.0)